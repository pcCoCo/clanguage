# day08-指针

指针是C语言的灵魂。


## 指针的概念

* 指针是C语言的灵魂,C语言中的指针及其灵活,正是因为C语言中有指针,C语言才能在最近40年经久不衰。

* 指针的概念
    * 指针变量也是一种变量。
    * 指针存放的内容是一个地址，该地址指向一块内存空间。
    * 指针也是一种数据类型。
    
    
## 指针变量

    可以定义一个指向一个变量的指针变量。
    
`int *p ` 表示定义一个指针变量。
`*p` 代表指针所指内存的数据内容。

**注意**： 指针变量只能存放地址，不能将一个int型的变量直接赋值给指针变量。如：`int *p = 100;`
    
    
## &取地址运算符
    &可以获取一个变量在内存中的地址。
 
**    注意：**   `Register int a;`中，a是一个寄存器变量，这种变量不在内存中，而是在CPU里，没有地址，所以寄存器变量不能使用&来得到地址。

## 无类型指针
定义一个指针变量，但不指定它指向具体哪种数据类型。可以通过强制转化将`void *`转化为其他类型指针，也可以用`(void *)`将其他类型指针强制转化为void类型指针。
`void *p`，指针之间赋值需要类型相同，但任何类型的指针都可以赋值给`void *`。


## NULL和野指针
* NULL在C语言中的定义为(void *)0
    空指针就是指向了NULL的指针变量。
* 野指针，如果声明一个指针变量，没有初始化，那么这个指针变量的值是垃圾值，可能指向了一块随机的空间。这块空间可能是没有使用，也可能别的程序使用，也可能是系统占用。去访问指针指向的空间的时候,就可能会报错. BAD_ACCESS错误.这样的指针就叫做野指针。所以在代码中避免出现野指针，
* 如果一个指针不能确定指向任何一个变量的地址，那么就将这个指针赋值为NULL。


## 指针的兼容性
指针之间赋值比普通数据类型赋值检查更为严格，例如：不可以把一个`double *`赋值给`int *`。


## 指向常量的指针和指针常量

`const char *p;`定义一个指向常量的指针。

`char *const p;`定义一个指针常量，一旦初始化之后其内容不可改变。

**注意：**c语言中的const是有问题的，因为可以通过指针变量间接的修改const常量的值，所以在c语言中用#define常量的时候更多。

## 数组和指针

* 声明和定义
    
```
// 当指针指向数组,那么指针的变量名就可以当做数组名来用.

int main()
{

    int arr[10] = {1,2,3,4,5,6,7,8,9,10};

    int *p = arr;

    p[3] = 20;
    int i;
    for (i = 0; i < 10; i++) {
        printf("p[%d] = %d\n",i,p[i]);
    }

    return 0;
}
```

    
```
// 指针可以指向数组任意一个元素.

int main()
{
    int arr[10] = {1,2,3,4,5,6,7,8,9,10};

    int *p = &arr[2]; // p[0] 初始值为arr下标为2的元素

    p[3] = 20; // ---> 等价于 arr[5] = 20;
    int i;
    for (i = 0; i < 10; i++) {
        printf("p[%d] = %d\n",i,arr[i]);
    }

    return 0;
}
```

## 指针运算










    
    
## 指针的偏移

### 拓展
通常在C语言中仅当指针具有显式类型的时候才可用于计算。例如，int*或 long *。
否则不可能确定指针加1操作的语义，GNU编译器拓展了该限制，支持void类型的指针和函数指针的运算，在Linux内核中很多地方都有用到。这两种情况下加1的语义是增加一个字节。

有趣的是 GCC曾经支持过对bit寻址的体系结构，即TI(texas Instrument,德州仪器)的34010处理器。指针加1在该机器上意味着内存地址向前移动1bit位，而不是莆田的移动一个字节。
更有趣的是 2.6系列内核开发的关键人物 Andrew Morton曾经为该处理器编写过一个实时内核,可以从www.zip.com/au/~akpm/下载源代码。


